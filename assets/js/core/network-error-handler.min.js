class NetworkErrorHandler{constructor(){this.retryAttempts=3;this.retryDelay=1000;this.requestQueue=[];this.isOnline=navigator.onLine;this.failedRequests=new Map();this.init();}init(){window.addEventListener('online',this.handleOnline.bind(this));window.addEventListener('offline',this.handleOffline.bind(this));this.interceptFetch();}handleOnline(){this.isOnline=true;AionUtils.errors.show('Connection restored','success');this.retryFailedRequests();}handleOffline(){this.isOnline=false;AionUtils.errors.show('No internet connection. Some features may not work.','warning');}interceptFetch(){const originalFetch=window.fetch;window.fetch=async(url,options={})=>{return this.fetchWithErrorHandling(url,options,originalFetch);};}async fetchWithErrorHandling(url,options,originalFetch){const requestId=this.generateRequestId();const maxRetries=options.maxRetries||this.retryAttempts;let attempt=0;while(attempt<=maxRetries){try{if(!this.isOnline){throw new Error('No internet connection');}const timeoutController=new AbortController();const timeout=options.timeout||10000;const timeoutId=setTimeout(()=>{timeoutController.abort();},timeout);const signal=options.signal?this.mergeAbortSignals([options.signal,timeoutController.signal]):timeoutController.signal;const response=await originalFetch(url,{...options,signal});clearTimeout(timeoutId);if(!response.ok){throw new Error(`HTTP ${response.status}:${response.statusText}`);}this.failedRequests.delete(requestId);return response;}catch(error){attempt++;:`,url,error.message);if(attempt<=maxRetries&&this.shouldRetry(error)){this.failedRequests.set(requestId,{url,options,originalFetch,attempts:attempt});await this.delay(this.retryDelay*attempt);continue;}this.handleFinalError(error,url,options);throw error;}}}shouldRetry(error){if(error.name==='AbortError')return false;if(error.message.includes('403')||error.message.includes('404'))return false;return error.message.includes('Failed to fetch')||error.message.includes('timeout')||error.message.includes('5');}handleFinalError(error,url,options){let userMessage='Network request failed';if(error.name==='AbortError'){userMessage='Request was cancelled';}else if(error.message.includes('timeout')){userMessage='Request timed out';}else if(error.message.includes('Failed to fetch')){userMessage='Unable to connect to server';}else if(error.message.includes('404')){userMessage='Requested content not found';}else if(error.message.includes('403')){userMessage='Access denied';}else if(error.message.includes('5')){userMessage='Server error occurred';}if(!options.silent){AionUtils.errors.show(userMessage,'error');}AionUtils.errors.log(error,`Network request to ${url}`);}async retryFailedRequests(){const requests=Array.from(this.failedRequests.entries());for(const[requestId,requestData]of requests){try{const{url,options,originalFetch}=requestData;await this.fetchWithErrorHandling(url,{...options,maxRetries:1},originalFetch);this.failedRequests.delete(requestId);}catch(error){}}}generateRequestId(){return `req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;}mergeAbortSignals(signals){const controller=new AbortController();signals.forEach(signal=>{if(signal.aborted){controller.abort();}else{signal.addEventListener('abort',()=>{controller.abort();});}});return controller.signal;}delay(ms){return new Promise(resolve=>setTimeout(resolve,ms));}getStatus(){return{online:this.isOnline,failedRequests:this.failedRequests.size,connection:this.getConnectionType()};}getConnectionType(){if('connection' in navigator){return{type:navigator.connection.effectiveType,downlink:navigator.connection.downlink,rtt:navigator.connection.rtt};}return null;}}window.networkErrorHandler=new NetworkErrorHandler();