<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 9: Ouroboros and Self-Renewal - Interactive Cycle of Transformation</title>
    <link rel="stylesheet" href="styles-v2.css">
    <link rel="stylesheet" href="responsive-utils.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="webgl-utils.js"></script>
    <script src="webgl-context-manager.js"></script>
    <script src="browser-compatibility.js"></script>
    <script src="error-boundaries.js"></script>
    <script src="accessibility-utils.js"></script>
    <script src="progress-tracker.js"></script>
    <script src="visualization-loader.js"></script>
    <script src="apply-fixes.js" defer></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-container">
            <a href="index.html" class="nav-link">Home</a>
            <a href="chapters.html" class="nav-link">Chapters</a>
            <a href="enhanced-chapters.html" class="nav-link">Enhanced</a>
            <a href="timeline.html" class="nav-link">Timeline</a>
            <a href="symbols.html" class="nav-link">Symbols</a>
            <a href="about.html" class="nav-link">About</a>
        </div>
    </nav>

    <main class="chapter-content">
        <div class="chapter-header">
            <div class="chapter-number">Chapter IX</div>
            <h1 class="chapter-title">The Ouroboros</h1>
            <p class="chapter-subtitle">The Eternal Cycle of Self-Renewal</p>
        </div>

        <section class="chapter-intro">
            <p>The Ouroboros - the serpent that eats its own tail - represents the eternal cycle of destruction and creation, death and rebirth. In Jung's psychology, it symbolizes the circular nature of individuation, where endings become beginnings in the spiral journey toward wholeness.</p>
        </section>

        <!-- Animated Ouroboros Visualization -->
        <section class="visualization-section">
            <h2>Living Ouroboros</h2>
            <div class="visualization-intro">
                <p>Experience the breathing, pulsing Ouroboros as a living symbol. Watch how destruction and creation flow into each other in eternal motion.</p>
            </div>
            <div id="ouroboros-container" class="visualization-container"></div>
            <div class="visualization-controls">
                <div class="control-group">
                    <button id="toggle-breathing">Toggle Breathing</button>
                    <button id="show-energy-flow">Show Energy Flow</button>
                    <button id="reverse-direction">Reverse Direction</button>
                </div>
                <div class="control-group">
                    <label for="cycle-speed">Cycle Speed:</label>
                    <input type="range" id="cycle-speed" min="1" max="10" value="5">
                    <span id="speed-value">5</span>
                </div>
                <div class="control-group">
                    <button id="show-dissolution">Show Dissolution</button>
                    <button id="show-regeneration">Show Regeneration</button>
                    <button id="show-transformation">Full Transformation</button>
                </div>
            </div>
        </section>

        <!-- Personal Lifecycle Journey -->
        <section class="visualization-section">
            <h2>Personal Renewal Journey</h2>
            <div class="visualization-intro">
                <p>Map your own cycles of death and rebirth. Identify patterns of endings and beginnings in your psychological development.</p>
            </div>
            <div id="lifecycle-journey" class="visualization-container">
                <div class="journey-interface">
                    <div class="cycle-input">
                        <h3>Add Life Cycle</h3>
                        <div class="input-group">
                            <label for="cycle-title">Cycle Name:</label>
                            <input type="text" id="cycle-title" placeholder="e.g., Career transition, Relationship ending">
                        </div>
                        <div class="input-group">
                            <label for="cycle-type">Type:</label>
                            <select id="cycle-type">
                                <option value="death">Death/Ending</option>
                                <option value="gestation">Gestation/Transition</option>
                                <option value="birth">Birth/Beginning</option>
                                <option value="growth">Growth/Development</option>
                                <option value="maturity">Maturity/Completion</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="cycle-date">Approximate Date:</label>
                            <input type="month" id="cycle-date">
                        </div>
                        <div class="input-group">
                            <label for="cycle-description">Description:</label>
                            <textarea id="cycle-description" rows="3" placeholder="Describe this phase of your journey..."></textarea>
                        </div>
                        <button id="add-cycle">Add to Journey</button>
                    </div>
                    
                    <div class="cycle-visualization">
                        <h3>Your Renewal Cycles</h3>
                        <div id="personal-ouroboros"></div>
                        <div class="cycle-legend">
                            <div class="legend-item">
                                <span class="legend-color" style="background: #2F2F2F"></span> Death/Ending
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #666666"></span> Gestation
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #FFD700"></span> Birth
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #7CFC00"></span> Growth
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #DC143C"></span> Maturity
                            </div>
                        </div>
                    </div>
                    
                    <div class="cycle-analysis">
                        <h3>Pattern Analysis</h3>
                        <div id="pattern-insights"></div>
                        <button id="analyze-patterns">Analyze My Cycles</button>
                        <button id="export-journey">Export Journey</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Mandala Creation Tool -->
        <section class="visualization-section">
            <h2>Ouroboros Mandala Creator</h2>
            <div class="visualization-intro">
                <p>Create your own circular mandala incorporating the ouroboros principle. Design patterns that represent your personal cycles of transformation.</p>
            </div>
            <div id="mandala-creator" class="visualization-container">
                <div class="creator-interface">
                    <div class="tool-palette">
                        <h3>Drawing Tools</h3>
                        <div class="tool-group">
                            <button class="tool-btn active" data-tool="circle">Circle</button>
                            <button class="tool-btn" data-tool="spiral">Spiral</button>
                            <button class="tool-btn" data-tool="snake">Snake</button>
                            <button class="tool-btn" data-tool="symbol">Symbol</button>
                        </div>
                        <div class="color-group">
                            <label>Color:</label>
                            <input type="color" id="draw-color" value="#6B46C1">
                        </div>
                        <div class="size-group">
                            <label>Size:</label>
                            <input type="range" id="draw-size" min="1" max="50" value="10">
                        </div>
                    </div>
                    
                    <div class="mandala-canvas">
                        <canvas id="mandala-drawing" width="600" height="600"></canvas>
                        <div class="canvas-controls">
                            <button id="clear-mandala">Clear</button>
                            <button id="save-mandala">Save</button>
                            <button id="load-template">Load Template</button>
                            <button id="mirror-mode">Mirror Mode</button>
                        </div>
                    </div>
                    
                    <div class="mandala-gallery">
                        <h3>Saved Mandalas</h3>
                        <div id="saved-mandalas"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Meditation Timer -->
        <section class="visualization-section">
            <h2>Ouroboros Meditation</h2>
            <div class="visualization-intro">
                <p>Use the cyclic breathing of the Ouroboros as a meditation focus. Synchronize your breath with the eternal cycle.</p>
            </div>
            <div id="meditation-timer" class="visualization-container">
                <div class="meditation-interface">
                    <div class="timer-display">
                        <div id="meditation-ouroboros"></div>
                        <div class="timer-text">
                            <h3 id="timer-phase">Prepare</h3>
                            <div id="timer-count">00:00</div>
                        </div>
                    </div>
                    
                    <div class="meditation-controls">
                        <div class="duration-select">
                            <label>Duration:</label>
                            <select id="meditation-duration">
                                <option value="5">5 minutes</option>
                                <option value="10" selected>10 minutes</option>
                                <option value="15">15 minutes</option>
                                <option value="20">20 minutes</option>
                                <option value="30">30 minutes</option>
                            </select>
                        </div>
                        <div class="meditation-buttons">
                            <button id="start-meditation">Start</button>
                            <button id="pause-meditation" disabled>Pause</button>
                            <button id="stop-meditation" disabled>Stop</button>
                        </div>
                        <div class="breath-guide">
                            <label>
                                <input type="checkbox" id="breath-guide-enabled" checked>
                                Enable breath guide
                            </label>
                        </div>
                    </div>
                    
                    <div class="meditation-log">
                        <h3>Meditation Journal</h3>
                        <textarea id="meditation-notes" placeholder="Record your insights..."></textarea>
                        <button id="save-meditation">Save Session</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Educational Content -->
        <section class="content-section">
            <h2>The Psychology of Eternal Return</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h3>Cyclic Nature of Psyche</h3>
                    <p>The psyche operates in cycles rather than linear progression. What appears as regression often precedes the next level of development.</p>
                    <ul>
                        <li>Spiral development model</li>
                        <li>Return with new understanding</li>
                        <li>Integration through repetition</li>
                        <li>Depth through cycles</li>
                    </ul>
                </div>
                
                <div class="concept-card">
                    <h3>Death and Rebirth</h3>
                    <p>Psychological transformation requires the death of old patterns and identities to make room for new growth and understanding.</p>
                    <ul>
                        <li>Ego death experiences</li>
                        <li>Identity transformation</li>
                        <li>Letting go as prerequisite</li>
                        <li>Phoenix principle</li>
                    </ul>
                </div>
                
                <div class="concept-card">
                    <h3>Self-Devouring</h3>
                    <p>The ouroboros eating itself represents consciousness examining itself, leading to both destruction and renewal of understanding.</p>
                    <ul>
                        <li>Self-reflection as dissolution</li>
                        <li>Analysis as creative destruction</li>
                        <li>Consciousness feeding on itself</li>
                        <li>Knowledge through self-consumption</li>
                    </ul>
                </div>
                
                <div class="concept-card">
                    <h3>Eternal Return</h3>
                    <p>Nietzsche's concept of eternal return finds psychological expression in the recurring patterns and themes of individuation.</p>
                    <ul>
                        <li>Archetypal repetitions</li>
                        <li>Generational patterns</li>
                        <li>Personal myth cycles</li>
                        <li>Timeless present moment</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Jung Quotes -->
        <section class="content-section">
            <h2>Jung on the Ouroboros</h2>
            <div class="quotes-container">
                <blockquote class="jung-quote">
                    <p>"The ouroboros is a dramatic symbol for the integration and assimilation of the opposite, i.e., of the shadow."</p>
                    <cite>— Carl Jung, Collected Works</cite>
                </blockquote>
                
                <blockquote class="jung-quote">
                    <p>"The way is not straight but appears to go round in circles. For knowledge of the center is repeatedly lost and must be found again."</p>
                    <cite>— Carl Jung, Psychology and Alchemy</cite>
                </blockquote>
                
                <blockquote class="jung-quote">
                    <p>"The self is not only the centre, but also the whole circumference which embraces both conscious and unconscious; it is the centre of this totality."</p>
                    <cite>— Carl Jung, Psychology and Alchemy</cite>
                </blockquote>
                
                <blockquote class="jung-quote">
                    <p>"Life has always seemed to me like a plant that lives on its rhizome. Its true life is invisible, hidden in the rhizome."</p>
                    <cite>— Carl Jung, Memories, Dreams, Reflections</cite>
                </blockquote>
            </div>
        </section>
    </main>

    <style>
        .ouroboros-visualization {
            position: relative;
            width: 100%;
            height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(107, 70, 193, 0.1) 0%, transparent 70%);
            border-radius: 50%;
        }

        .journey-interface {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 2rem;
            padding: 2rem;
            background: var(--surface-glass);
            border-radius: 1rem;
            min-height: 500px;
        }

        .cycle-input {
            background: var(--surface-secondary);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-default);
        }

        .cycle-input h3 {
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 0.5rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 0.25rem;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 60px;
        }

        #add-cycle {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        #add-cycle:hover {
            background: var(--accent-dark);
            transform: translateY(-1px);
        }

        .cycle-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }

        .cycle-visualization h3 {
            color: var(--accent);
            margin-bottom: 1rem;
        }

        #personal-ouroboros {
            width: 100%;
            height: 300px;
            position: relative;
        }

        .cycle-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid var(--border-default);
        }

        .cycle-analysis {
            background: var(--surface-secondary);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-default);
        }

        .cycle-analysis h3 {
            color: var(--accent);
            margin-bottom: 1rem;
        }

        #pattern-insights {
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--surface-glass);
            border-radius: 0.25rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            min-height: 100px;
        }

        .cycle-analysis button {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-default);
            border-radius: 0.25rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cycle-analysis button:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .creator-interface {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 2rem;
            padding: 2rem;
            background: var(--surface-glass);
            border-radius: 1rem;
        }

        .tool-palette {
            background: var(--surface-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-default);
        }

        .tool-palette h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .tool-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tool-btn {
            padding: 0.5rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 0.25rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .tool-btn.active,
        .tool-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .color-group,
        .size-group {
            margin-bottom: 1rem;
        }

        .color-group label,
        .size-group label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        #draw-color {
            width: 100%;
            height: 40px;
            border: 1px solid var(--border-default);
            border-radius: 0.25rem;
            cursor: pointer;
        }

        #draw-size {
            width: 100%;
        }

        .mandala-canvas {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #mandala-drawing {
            background: var(--surface-primary);
            border: 2px solid var(--border-default);
            border-radius: 50%;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }

        .canvas-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-controls button {
            padding: 0.5rem 1rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-default);
            border-radius: 0.25rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .canvas-controls button:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .mandala-gallery {
            background: var(--surface-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-default);
            max-height: 600px;
            overflow-y: auto;
        }

        .mandala-gallery h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .saved-mandala {
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .saved-mandala img {
            width: 100%;
            border-radius: 50%;
            border: 2px solid var(--border-subtle);
        }

        .saved-mandala:hover img {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .meditation-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: var(--surface-glass);
            border-radius: 1rem;
        }

        .timer-display {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #meditation-ouroboros {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .timer-text {
            position: relative;
            text-align: center;
            z-index: 10;
        }

        #timer-phase {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        #timer-count {
            font-size: 3rem;
            font-weight: 300;
            color: var(--text-primary);
        }

        .meditation-controls {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .duration-select label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-right: 0.5rem;
        }

        .duration-select select {
            padding: 0.5rem;
            background: var(--surface-secondary);
            border: 1px solid var(--border-default);
            border-radius: 0.25rem;
            color: var(--text-primary);
        }

        .meditation-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .meditation-buttons button {
            padding: 0.75rem 1.5rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .meditation-buttons button:hover:not(:disabled) {
            background: var(--accent-dark);
            transform: translateY(-1px);
        }

        .meditation-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .breath-guide label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .meditation-log {
            width: 100%;
            max-width: 500px;
            background: var(--surface-secondary);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-default);
        }

        .meditation-log h3 {
            color: var(--accent);
            margin-bottom: 1rem;
        }

        #meditation-notes {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 0.25rem;
            color: var(--text-primary);
            resize: vertical;
            margin-bottom: 1rem;
        }

        #save-meditation {
            width: 100%;
            padding: 0.75rem;
            background: var(--surface-glass);
            border: 1px solid var(--border-default);
            border-radius: 0.25rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #save-meditation:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        @media (max-width: 768px) {
            .journey-interface,
            .creator-interface {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 1rem;
            }

            .meditation-controls {
                flex-direction: column;
                gap: 1rem;
            }

            #timer-count {
                font-size: 2rem;
            }

            .timer-display {
                width: 250px;
                height: 250px;
            }
        }
    </style>

    <script>
        // Enhanced Chapter 9: Ouroboros Implementation
        document.addEventListener('DOMContentLoaded', () => {
            initializeOuroboros();
            initializeLifecycleJourney();
            initializeMandalaCreator();
            initializeMeditationTimer();
        });

        function initializeOuroboros() {
            const container = document.getElementById('ouroboros-container');
            if (!container) return;

            const width = container.offsetWidth;
            const height = 500;

            // Create Three.js scene with optimized context
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Use optimized WebGL context
            const canvas = document.createElement('canvas');
            const gl = window.createOptimizedWebGLContext(canvas, {
                alpha: true,
                antialias: !window.webglContextManager.isLowMemoryDevice,
                powerPreference: 'default'
            });
            
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                context: gl,
                alpha: true,
                antialias: !window.webglContextManager.isLowMemoryDevice
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);

            // Add accessibility
            renderer.domElement.setAttribute('role', 'img');
            renderer.domElement.setAttribute('aria-label', 'Animated ouroboros serpent forming a circle of eternal renewal');
            renderer.domElement.setAttribute('tabindex', '0');

            container.appendChild(renderer.domElement);

            // Add screen reader description
            const description = document.createElement('div');
            description.id = 'ouroboros-description';
            description.className = 'sr-only';
            description.innerHTML = `
                <h3>Ouroboros Visualization Description</h3>
                <p>This animation shows a serpent forming a perfect circle by swallowing its own tail, representing the eternal cycle of destruction and creation. The serpent breathes and pulses with life energy, demonstrating how endings flow seamlessly into new beginnings.</p>
            `;
            container.appendChild(description);
            renderer.domElement.setAttribute('aria-describedby', 'ouroboros-description');

            camera.position.set(0, 0, 10);

            // Ouroboros parameters
            let breathingEnabled = true;
            let energyFlowEnabled = false;
            let cycleSpeed = 5;
            let direction = 1;

            // Create ouroboros geometry
            const segmentCount = 100;
            const radius = 3;
            const tubeRadius = 0.3;
            
            // Create custom geometry for the ouroboros
            function createOuroborosGeometry(time) {
                const points = [];
                
                for (let i = 0; i <= segmentCount; i++) {
                    const angle = (i / segmentCount) * Math.PI * 2;
                    const breathingOffset = breathingEnabled ? Math.sin(time * 0.002) * 0.1 : 0;
                    const currentRadius = radius + breathingOffset;
                    
                    const x = Math.cos(angle) * currentRadius;
                    const y = Math.sin(angle) * currentRadius;
                    const z = Math.sin(angle * 3 + time * 0.001) * 0.2; // Subtle 3D movement
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                return points;
            }

            // Create tube geometry
            let ouroborosPoints = createOuroborosGeometry(0);
            let curve = new THREE.CatmullRomCurve3(ouroborosPoints);
            curve.closed = true;
            
            const tubeGeometry = new THREE.TubeGeometry(curve, segmentCount * 2, tubeRadius, 16, true);
            
            // Create gradient material
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    energyFlow: { value: 0.0 }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float energyFlow;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 color1 = vec3(0.42, 0.27, 0.76); // Accent color
                        vec3 color2 = vec3(0.49, 0.23, 0.84); // Accent light
                        vec3 color3 = vec3(0.36, 0.13, 0.71); // Accent dark
                        
                        float gradient = vUv.x;
                        
                        // Add energy flow effect
                        if (energyFlow > 0.0) {
                            float flow = mod(vUv.x * 10.0 - time * 0.005, 1.0);
                            gradient += flow * energyFlow * 0.3;
                        }
                        
                        // Mix colors based on position
                        vec3 finalColor = mix(color1, color2, gradient);
                        finalColor = mix(finalColor, color3, sin(vUv.x * 6.28 + time * 0.001) * 0.5 + 0.5);
                        
                        // Add shimmer effect
                        float shimmer = sin(vUv.x * 50.0 + time * 0.01) * 0.1 + 0.9;
                        finalColor *= shimmer;
                        
                        gl_FragColor = vec4(finalColor, 0.9);
                    }
                `,
                transparent: true
            });

            const ouroboros = new THREE.Mesh(tubeGeometry, material);
            scene.add(ouroboros);

            // Create head
            const headGeometry = new THREE.ConeGeometry(tubeRadius * 1.5, tubeRadius * 3, 8);
            const headMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x6B46C1,
                transparent: true,
                opacity: 0.9
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.rotation.z = -Math.PI / 2;
            head.position.set(radius, 0, 0);
            scene.add(head);

            // Create eye
            const eyeGeometry = new THREE.SphereGeometry(tubeRadius * 0.3, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5
            });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.set(radius + tubeRadius, tubeRadius * 0.5, tubeRadius);
            scene.add(eye);

            // Animation variables
            let time = 0;

            // Animation loop
            function animate() {
                time += cycleSpeed;
                
                // Update material uniforms
                material.uniforms.time.value = time;
                material.uniforms.energyFlow.value = energyFlowEnabled ? 1.0 : 0.0;

                // Recreate geometry for breathing effect
                if (breathingEnabled && time % 10 === 0) {
                    const newPoints = createOuroborosGeometry(time);
                    const newCurve = new THREE.CatmullRomCurve3(newPoints);
                    newCurve.closed = true;
                    
                    const newGeometry = new THREE.TubeGeometry(newCurve, segmentCount * 2, tubeRadius, 16, true);
                    ouroboros.geometry.dispose();
                    ouroboros.geometry = newGeometry;
                }

                // Rotate entire ouroboros
                ouroboros.rotation.z += 0.001 * direction;
                head.rotation.y += 0.02;
                
                // Update head position
                const headAngle = ouroboros.rotation.z;
                head.position.x = Math.cos(headAngle) * radius;
                head.position.y = Math.sin(headAngle) * radius;
                head.rotation.z = headAngle - Math.PI / 2;
                
                // Update eye position
                eye.position.x = head.position.x + Math.cos(headAngle) * tubeRadius;
                eye.position.y = head.position.y + Math.sin(headAngle) * tubeRadius;

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            animate();

            // Control handlers
            document.getElementById('toggle-breathing').addEventListener('click', () => {
                breathingEnabled = !breathingEnabled;
            });

            document.getElementById('show-energy-flow').addEventListener('click', () => {
                energyFlowEnabled = !energyFlowEnabled;
            });

            document.getElementById('reverse-direction').addEventListener('click', () => {
                direction *= -1;
            });

            document.getElementById('cycle-speed').addEventListener('input', (e) => {
                cycleSpeed = parseInt(e.target.value);
                document.getElementById('speed-value').textContent = cycleSpeed;
            });

            // Transformation animations
            document.getElementById('show-dissolution').addEventListener('click', () => {
                material.uniforms.time.value += 1000;
            });

            document.getElementById('show-regeneration').addEventListener('click', () => {
                breathingEnabled = true;
                setTimeout(() => {
                    energyFlowEnabled = true;
                }, 1000);
            });

            document.getElementById('show-transformation').addEventListener('click', () => {
                // Full transformation sequence
                breathingEnabled = false;
                energyFlowEnabled = false;
                
                setTimeout(() => {
                    breathingEnabled = true;
                }, 1000);
                
                setTimeout(() => {
                    energyFlowEnabled = true;
                }, 2000);
                
                setTimeout(() => {
                    direction *= -1;
                }, 3000);
            });

            // Handle resize
            window.addEventListener('resize', () => {
                const newWidth = container.offsetWidth;
                camera.aspect = newWidth / height;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, height);
            });
        }

        function initializeLifecycleJourney() {
            const cycles = [];
            const colors = {
                'death': '#2F2F2F',
                'gestation': '#666666',
                'birth': '#FFD700',
                'growth': '#7CFC00',
                'maturity': '#DC143C'
            };

            function addCycle() {
                const title = document.getElementById('cycle-title').value;
                const type = document.getElementById('cycle-type').value;
                const date = document.getElementById('cycle-date').value;
                const description = document.getElementById('cycle-description').value;

                if (!title) {
                    alert('Please enter a cycle name');
                    return;
                }

                const cycle = {
                    id: Date.now(),
                    title,
                    type,
                    date,
                    description,
                    color: colors[type]
                };

                cycles.push(cycle);
                updateVisualization();
                clearForm();
            }

            function clearForm() {
                document.getElementById('cycle-title').value = '';
                document.getElementById('cycle-type').value = 'death';
                document.getElementById('cycle-date').value = '';
                document.getElementById('cycle-description').value = '';
            }

            function updateVisualization() {
                const container = document.getElementById('personal-ouroboros');
                if (!container) return;

                // Clear existing visualization
                container.innerHTML = '';

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', '0 0 400 300');

                const centerX = 200;
                const centerY = 150;
                const radius = 100;

                // Draw ouroboros path
                const pathData = d3.arc()
                    .innerRadius(radius - 20)
                    .outerRadius(radius + 20)
                    .startAngle(0)
                    .endAngle(2 * Math.PI);

                svg.append('path')
                    .attr('d', pathData)
                    .attr('transform', `translate(${centerX}, ${centerY})`)
                    .attr('fill', 'none')
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);

                // Add cycles as segments
                if (cycles.length > 0) {
                    const anglePerCycle = (2 * Math.PI) / cycles.length;
                    
                    cycles.forEach((cycle, index) => {
                        const startAngle = index * anglePerCycle;
                        const endAngle = (index + 1) * anglePerCycle;
                        
                        const segmentArc = d3.arc()
                            .innerRadius(radius - 15)
                            .outerRadius(radius + 15)
                            .startAngle(startAngle)
                            .endAngle(endAngle);

                        const g = svg.append('g')
                            .attr('transform', `translate(${centerX}, ${centerY})`);

                        g.append('path')
                            .attr('d', segmentArc)
                            .attr('fill', cycle.color)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 1)
                            .attr('opacity', 0.8)
                            .on('mouseover', function() {
                                d3.select(this).attr('opacity', 1);
                                showCycleDetails(cycle);
                            })
                            .on('mouseout', function() {
                                d3.select(this).attr('opacity', 0.8);
                            });

                        // Add label
                        const labelAngle = startAngle + anglePerCycle / 2;
                        const labelX = Math.cos(labelAngle - Math.PI / 2) * (radius + 30);
                        const labelY = Math.sin(labelAngle - Math.PI / 2) * (radius + 30);

                        g.append('text')
                            .attr('x', labelX)
                            .attr('y', labelY)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', '#fff')
                            .text(cycle.title.substring(0, 15) + (cycle.title.length > 15 ? '...' : ''));
                    });
                }
            }

            function showCycleDetails(cycle) {
                const insights = document.getElementById('pattern-insights');
                insights.innerHTML = `
                    <h4>${cycle.title}</h4>
                    <p><strong>Type:</strong> ${cycle.type.charAt(0).toUpperCase() + cycle.type.slice(1)}</p>
                    <p><strong>Date:</strong> ${cycle.date || 'Not specified'}</p>
                    <p><strong>Description:</strong> ${cycle.description || 'No description'}</p>
                `;
            }

            function analyzePatterns() {
                const insights = document.getElementById('pattern-insights');
                
                if (cycles.length === 0) {
                    insights.innerHTML = '<p>Add some cycles to see pattern analysis.</p>';
                    return;
                }

                const typeCounts = {};
                cycles.forEach(cycle => {
                    typeCounts[cycle.type] = (typeCounts[cycle.type] || 0) + 1;
                });

                let analysis = '<h4>Your Cycle Patterns</h4>';
                analysis += '<ul>';
                
                const total = cycles.length;
                for (const [type, count] of Object.entries(typeCounts)) {
                    const percentage = Math.round((count / total) * 100);
                    analysis += `<li>${type}: ${count} cycles (${percentage}%)</li>`;
                }
                analysis += '</ul>';

                if (typeCounts.death > typeCounts.birth) {
                    analysis += '<p><strong>Insight:</strong> You have more endings than beginnings recorded. This might indicate you\'re in a phase of letting go and transformation.</p>';
                } else if (typeCounts.birth > typeCounts.death) {
                    analysis += '<p><strong>Insight:</strong> You have more beginnings than endings. This suggests you\'re in a creative, expansive phase.</p>';
                }

                insights.innerHTML = analysis;
            }

            // Event handlers
            document.getElementById('add-cycle').addEventListener('click', addCycle);
            document.getElementById('analyze-patterns').addEventListener('click', analyzePatterns);
            
            document.getElementById('export-journey').addEventListener('click', () => {
                const data = JSON.stringify(cycles, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'my-ouroboros-journey.json';
                a.click();
            });
        }

        function initializeMandalaCreator() {
            const canvas = document.getElementById('mandala-drawing');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let currentTool = 'circle';
            let currentColor = '#6B46C1';
            let currentSize = 10;
            let isDrawing = false;
            let mirrorMode = false;
            const savedMandalas = [];

            // Set up canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Tool selection
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                });
            });

            // Color and size
            document.getElementById('draw-color').addEventListener('change', (e) => {
                currentColor = e.target.value;
            });

            document.getElementById('draw-size').addEventListener('input', (e) => {
                currentSize = parseInt(e.target.value);
            });

            // Drawing functions
            function drawAtPosition(x, y) {
                ctx.fillStyle = currentColor;
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 2;

                switch (currentTool) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(x, y, currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    
                    case 'spiral':
                        drawSpiral(x, y, currentSize);
                        break;
                    
                    case 'snake':
                        if (isDrawing) {
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                        }
                        break;
                    
                    case 'symbol':
                        drawSymbol(x, y, currentSize);
                        break;
                }

                // Mirror drawing
                if (mirrorMode) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const mirrorX = centerX - (x - centerX);
                    const mirrorY = centerY - (y - centerY);
                    
                    switch (currentTool) {
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(mirrorX, mirrorY, currentSize, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        // Add other mirror cases as needed
                    }
                }
            }

            function drawSpiral(centerX, centerY, size) {
                ctx.beginPath();
                for (let i = 0; i < 50; i++) {
                    const angle = 0.1 * i;
                    const x = centerX + (size * angle / 10) * Math.cos(angle);
                    const y = centerY + (size * angle / 10) * Math.sin(angle);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            function drawSymbol(x, y, size) {
                ctx.font = `${size * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const symbols = ['☉', '☽', '♀', '♂', '☿', '♃', '♄'];
                const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                ctx.fillText(symbol, x, y);
            }

            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drawAtPosition(x, y);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drawAtPosition(x, y);
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });

            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                drawAtPosition(x, y);
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                drawAtPosition(x, y);
            });

            canvas.addEventListener('touchend', () => {
                isDrawing = false;
            });

            // Control buttons
            document.getElementById('clear-mandala').addEventListener('click', () => {
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });

            document.getElementById('save-mandala').addEventListener('click', () => {
                const dataURL = canvas.toDataURL();
                const mandala = {
                    id: Date.now(),
                    data: dataURL,
                    date: new Date().toISOString()
                };
                savedMandalas.push(mandala);
                updateGallery();
            });

            document.getElementById('load-template').addEventListener('click', () => {
                // Load ouroboros template
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#6B46C1';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                ctx.stroke();
            });

            document.getElementById('mirror-mode').addEventListener('click', () => {
                mirrorMode = !mirrorMode;
                document.getElementById('mirror-mode').textContent = mirrorMode ? 'Mirror Mode ON' : 'Mirror Mode';
            });

            function updateGallery() {
                const gallery = document.getElementById('saved-mandalas');
                gallery.innerHTML = '';
                
                savedMandalas.forEach(mandala => {
                    const div = document.createElement('div');
                    div.className = 'saved-mandala';
                    div.innerHTML = `<img src="${mandala.data}" alt="Saved mandala">`;
                    div.addEventListener('click', () => {
                        const img = new Image();
                        img.onload = function() {
                            ctx.drawImage(img, 0, 0);
                        };
                        img.src = mandala.data;
                    });
                    gallery.appendChild(div);
                });
            }
        }

        function initializeMeditationTimer() {
            let meditationInterval = null;
            let secondsRemaining = 0;
            let isPaused = false;

            const startBtn = document.getElementById('start-meditation');
            const pauseBtn = document.getElementById('pause-meditation');
            const stopBtn = document.getElementById('stop-meditation');
            const timerPhase = document.getElementById('timer-phase');
            const timerCount = document.getElementById('timer-count');

            // Create simple ouroboros animation for meditation
            const container = document.getElementById('meditation-ouroboros');
            if (container) {
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', '0 0 300 300');

                const circle = svg.append('circle')
                    .attr('cx', 150)
                    .attr('cy', 150)
                    .attr('r', 100)
                    .attr('fill', 'none')
                    .attr('stroke', '#6B46C1')
                    .attr('stroke-width', 20)
                    .attr('stroke-dasharray', '628 628')
                    .attr('transform', 'rotate(-90 150 150)');

                // Breathing animation
                function breathe() {
                    circle.transition()
                        .duration(4000)
                        .attr('r', 110)
                        .transition()
                        .duration(4000)
                        .attr('r', 100)
                        .on('end', breathe);
                }
                breathe();
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            function updateTimer() {
                if (secondsRemaining <= 0) {
                    stopMeditation();
                    timerPhase.textContent = 'Complete';
                    // Could play a sound here
                    return;
                }

                secondsRemaining--;
                timerCount.textContent = formatTime(secondsRemaining);

                // Update phase based on time
                const duration = parseInt(document.getElementById('meditation-duration').value) * 60;
                const elapsed = duration - secondsRemaining;
                const progress = elapsed / duration;

                if (progress < 0.1) {
                    timerPhase.textContent = 'Settling';
                } else if (progress < 0.3) {
                    timerPhase.textContent = 'Dissolving';
                } else if (progress < 0.7) {
                    timerPhase.textContent = 'Being';
                } else if (progress < 0.9) {
                    timerPhase.textContent = 'Emerging';
                } else {
                    timerPhase.textContent = 'Completing';
                }
            }

            function startMeditation() {
                const duration = parseInt(document.getElementById('meditation-duration').value);
                secondsRemaining = duration * 60;
                isPaused = false;

                startBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;

                timerPhase.textContent = 'Beginning';
                timerCount.textContent = formatTime(secondsRemaining);

                meditationInterval = setInterval(updateTimer, 1000);
            }

            function pauseMeditation() {
                if (isPaused) {
                    meditationInterval = setInterval(updateTimer, 1000);
                    pauseBtn.textContent = 'Pause';
                    isPaused = false;
                } else {
                    clearInterval(meditationInterval);
                    pauseBtn.textContent = 'Resume';
                    isPaused = true;
                }
            }

            function stopMeditation() {
                clearInterval(meditationInterval);
                secondsRemaining = 0;
                isPaused = false;

                startBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;

                timerPhase.textContent = 'Ready';
                timerCount.textContent = '00:00';
            }

            // Event handlers
            startBtn.addEventListener('click', startMeditation);
            pauseBtn.addEventListener('click', pauseMeditation);
            stopBtn.addEventListener('click', stopMeditation);

            document.getElementById('save-meditation').addEventListener('click', () => {
                const notes = document.getElementById('meditation-notes').value;
                if (!notes) {
                    alert('Please add some notes about your meditation experience');
                    return;
                }

                const session = {
                    date: new Date().toISOString(),
                    duration: document.getElementById('meditation-duration').value,
                    notes: notes
                };

                // Save to localStorage
                const sessions = JSON.parse(localStorage.getItem('meditationSessions') || '[]');
                sessions.push(session);
                localStorage.setItem('meditationSessions', JSON.stringify(sessions));

                document.getElementById('meditation-notes').value = '';
                alert('Meditation session saved!');
            });
        }
    </script>
</body>
</html>