<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 11 - The Alchemical Interpretation of the Fish - Aion</title>
    <link rel="stylesheet" href="/styles/full-width.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Georgia, serif;
            background: #000;
            color: #fff;
            line-height: 1.8;
        }
        
        /* Chapter Header */
        .chapter-header {
            padding: 4rem 2rem;
            text-align: center;
            background: linear-gradient(180deg, rgba(212, 175, 55, 0.1) 0%, transparent 100%);
            border-bottom: 1px solid #333;
        }
        
        .chapter-number {
            font-size: 1.2rem;
            color: #D4AF37;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }
        
        .chapter-title {
            font-size: 3rem;
            font-weight: 300;
            color: #fff;
            margin-bottom: 2rem;
        }
        
        .chapter-summary {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1.3rem;
            color: #ccc;
            font-style: italic;
        }
        
        /* Chapter Content */
        .chapter-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }
        
        .section {
            margin-bottom: 3rem;
        }
        
        .section h2 {
            font-size: 2rem;
            color: #D4AF37;
            margin-bottom: 1.5rem;
            font-weight: 300;
        }
        
        .section p {
            font-size: 1.1rem;
            color: #ddd;
            margin-bottom: 1.5rem;
        }
        
        .quote-box {
            background: rgba(212, 175, 55, 0.05);
            border-left: 4px solid #D4AF37;
            padding: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
        }
        
        .quote-box cite {
            display: block;
            margin-top: 1rem;
            color: #888;
            font-style: normal;
            text-align: right;
        }
        
        /* Chapter Navigation */
        .chapter-nav {
            max-width: 800px;
            margin: 0 auto;
            padding: 3rem 2rem;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #333;
        }
        
        .nav-link {
            color: #D4AF37;
            text-decoration: none;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .nav-link:hover {
            transform: translateX(5px);
        }
        
        .nav-link.prev:hover {
            transform: translateX(-5px);
        }
        
        /* Visualization Containers */
        .viz-container {
            background: rgba(10, 10, 10, 0.9);
            border-radius: 12px;
            overflow: hidden;
            margin: 3rem 0;
            border: 1px solid rgba(212, 175, 55, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .viz-container h3 {
            font-size: 1.5rem;
            color: #D4AF37;
            padding: 1.5rem;
            background: rgba(212, 175, 55, 0.05);
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            margin: 0;
        }
        
        .viz-container > div {
            min-height: 500px;
            position: relative;
        }
        
        .viz-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Interactive controls */
        .viz-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 10;
        }
        
        .viz-controls button {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: Georgia, serif;
            transition: all 0.3s ease;
        }
        
        .viz-controls button:hover {
            background: rgba(212, 175, 55, 0.3);
            transform: translateY(-2px);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .chapter-title {
                font-size: 2rem;
            }
            
            .chapter-summary {
                font-size: 1.1rem;
            }
            
            .section h2 {
                font-size: 1.5rem;
            }
            
            .viz-container {
                margin: 2rem -1rem;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Chapter Header -->
    <header class="chapter-header">
        <div class="chapter-number">Chapter 11</div>
        <h1 class="chapter-title">The Alchemical Interpretation of the Fish</h1>
        <p class="chapter-summary">Deeper explorations of fish symbolism in the hermetic tradition</p>
    </header>
    
    <!-- Chapter Content -->
    <main class="chapter-content">
        <section class="section">
            <h2>Overview</h2>
            <p>Building on the previous chapter, Jung delves deeper into specific alchemical texts and traditions to uncover the multilayered meanings of the fish symbol. He reveals how alchemists used the fish to encode profound psychological truths about the nature of consciousness and transformation.</p>
            <p>This chapter demonstrates how alchemical symbolism provides a bridge between ancient wisdom and modern psychology, with the fish serving as a key to understanding the mysterious processes of psychological transformation.</p>
        </section>
        
        <section class="section">
            <h2>Key Themes</h2>
            <p><strong>The Fish as Soul:</strong> Jung explores how alchemists viewed the fish as representing the soul imprisoned in matter, swimming in the waters of the physical world while yearning for spiritual transformation.</p>
            
            <!-- Visualization 1: The Fish as Soul -->
            <div class="viz-container">
                <h3>The Fish as Soul - Swimming in Alchemical Vessels</h3>
                <div id="fish-soul-viz">
                    <canvas id="fishSoulCanvas"></canvas>
                </div>
            </div>
            
            <p><strong>Multiplication and Unity:</strong> The chapter examines the paradox of the "one and many" fish - how the single fish divides into many yet remains one, reflecting the relationship between ego and Self.</p>
            
            <!-- Visualization 2: Multiplication and Unity -->
            <div class="viz-container">
                <h3>Multiplication and Unity - The Paradox of One Becoming Many</h3>
                <div id="multiplication-viz">
                    <canvas id="multiplicationCanvas"></canvas>
                    <div class="viz-controls">
                        <button onclick="toggleMultiplication()">Toggle Unity/Multiplicity</button>
                        <button onclick="resetMultiplication()">Reset</button>
                    </div>
                </div>
            </div>
            
            <p><strong>The Fish King:</strong> Jung analyzes the figure of the Rex Marinus or Sea King, the royal fish that rules the unconscious depths and must be caught and transformed to achieve the alchemical goal.</p>
            
            <!-- Visualization 3: The Fish King -->
            <div class="viz-container">
                <h3>Rex Marinus - The Royal Fish of the Depths</h3>
                <div id="fish-king-viz">
                    <canvas id="fishKingCanvas"></canvas>
                </div>
            </div>
        </section>
        
        <div class="quote-box">
            "In the alchemical fish we encounter the paradox of the Self: it is both the humble creature in the depths and the royal presence that rules over the entire psychic ocean."
            <cite>- C.G. Jung, Aion</cite>
        </div>
        
        <section class="section">
            <h2>Psychological Parallels</h2>
            <p>Jung draws explicit parallels between alchemical operations on the fish and stages of psychological development. The catching, killing, cooking, and eating of the symbolic fish correspond to different phases of integrating unconscious contents.</p>
            
            <!-- Visualization 4: Alchemical Transformation Stages -->
            <div class="viz-container">
                <h3>Alchemical Transformation Stages - The Journey of Integration</h3>
                <div id="transformation-viz">
                    <canvas id="transformationCanvas"></canvas>
                    <div class="viz-controls">
                        <button onclick="showStage('catching')">Catching</button>
                        <button onclick="showStage('killing')">Killing</button>
                        <button onclick="showStage('cooking')">Cooking</button>
                        <button onclick="showStage('eating')">Eating</button>
                        <button onclick="playSequence()">Play Full Sequence</button>
                    </div>
                </div>
            </div>
            
            <p>The chapter reveals how the alchemical tradition preserved essential knowledge about individuation in symbolic form, providing a rich source of insight for understanding the modern psyche's journey toward wholeness.</p>
        </section>
    </main>
    
    <!-- Chapter Navigation -->
    <nav class="chapter-nav">
        <a href="/chapters/chapter-10.html" class="nav-link prev">
            ← Chapter 10: The Fish in Alchemy
        </a>
        <a href="/chapters/chapter-12.html" class="nav-link next">
            Chapter 12: Background to the Psychology of Christian Alchemical Symbolism →
        </a>
    </nav>
    
    <script src="/components/navigation.js"></script>
    <script src="/js/ensure-viz-load.js"></script>
    
    <script>
    // Initialize all visualizations using the wrapper
    window.initializeVisualization(function() {
        console.log('Initializing Chapter 11 visualizations');
        
        // Visualization 1: The Fish as Soul
        const fishSoulCanvas = document.getElementById('fishSoulCanvas');
        const fsCtx = fishSoulCanvas.getContext('2d');
        let fishSoulAnimation;
        
        function initFishSoulViz() {
            fishSoulCanvas.width = fishSoulCanvas.parentElement.offsetWidth;
            fishSoulCanvas.height = 500;
            
            const vessels = [];
            const fish = [];
            
            // Create alchemical vessels
            for (let i = 0; i < 3; i++) {
                vessels.push({
                    x: (i + 1) * fishSoulCanvas.width / 4,
                    y: fishSoulCanvas.height / 2,
                    radius: 80,
                    rotation: 0,
                    glowIntensity: 0.5 + Math.random() * 0.5
                });
            }
            
            // Create fish swimming in vessels
            vessels.forEach((vessel, index) => {
                for (let j = 0; j < 3; j++) {
                    fish.push({
                        vessel: index,
                        angle: (j * Math.PI * 2) / 3,
                        radius: 30 + Math.random() * 20,
                        speed: 0.01 + Math.random() * 0.02,
                        size: 15 + Math.random() * 10,
                        color: `hsl(${45 + Math.random() * 15}, 70%, 50%)`,
                        tailPhase: Math.random() * Math.PI * 2
                    });
                }
            });
            
            function drawVessel(vessel) {
                fsCtx.save();
                fsCtx.translate(vessel.x, vessel.y);
                fsCtx.rotate(vessel.rotation);
                
                // Outer glow
                const gradient = fsCtx.createRadialGradient(0, 0, vessel.radius * 0.8, 0, 0, vessel.radius * 1.5);
                gradient.addColorStop(0, `rgba(212, 175, 55, ${vessel.glowIntensity * 0.1})`);
                gradient.addColorStop(1, 'transparent');
                fsCtx.fillStyle = gradient;
                fsCtx.fillRect(-vessel.radius * 2, -vessel.radius * 2, vessel.radius * 4, vessel.radius * 4);
                
                // Vessel shape (retort)
                fsCtx.strokeStyle = '#D4AF37';
                fsCtx.lineWidth = 2;
                fsCtx.beginPath();
                fsCtx.arc(0, 0, vessel.radius, 0, Math.PI * 2);
                fsCtx.stroke();
                
                // Neck of retort
                fsCtx.beginPath();
                fsCtx.moveTo(-vessel.radius * 0.3, -vessel.radius);
                fsCtx.lineTo(-vessel.radius * 0.3, -vessel.radius * 1.5);
                fsCtx.lineTo(vessel.radius * 0.3, -vessel.radius * 1.5);
                fsCtx.lineTo(vessel.radius * 0.3, -vessel.radius);
                fsCtx.stroke();
                
                // Alchemical symbols
                fsCtx.font = '24px Georgia';
                fsCtx.fillStyle = 'rgba(212, 175, 55, 0.5)';
                fsCtx.textAlign = 'center';
                fsCtx.fillText('☿', 0, vessel.radius + 30);
                
                fsCtx.restore();
            }
            
            function drawFish(f) {
                const vessel = vessels[f.vessel];
                const x = vessel.x + Math.cos(f.angle) * f.radius;
                const y = vessel.y + Math.sin(f.angle) * f.radius;
                
                fsCtx.save();
                fsCtx.translate(x, y);
                fsCtx.rotate(f.angle + Math.PI / 2);
                
                // Fish body
                fsCtx.fillStyle = f.color;
                fsCtx.beginPath();
                fsCtx.ellipse(0, 0, f.size * 0.4, f.size, 0, 0, Math.PI * 2);
                fsCtx.fill();
                
                // Fish tail
                const tailWave = Math.sin(f.tailPhase) * 0.3;
                fsCtx.beginPath();
                fsCtx.moveTo(0, f.size);
                fsCtx.quadraticCurveTo(f.size * tailWave, f.size * 1.3, -f.size * 0.5, f.size * 1.6);
                fsCtx.quadraticCurveTo(0, f.size * 1.3, f.size * 0.5, f.size * 1.6);
                fsCtx.quadraticCurveTo(-f.size * tailWave, f.size * 1.3, 0, f.size);
                fsCtx.fill();
                
                // Eye
                fsCtx.fillStyle = '#fff';
                fsCtx.beginPath();
                fsCtx.arc(-f.size * 0.2, -f.size * 0.3, 2, 0, Math.PI * 2);
                fsCtx.fill();
                
                fsCtx.restore();
            }
            
            function animateFishSoul() {
                fsCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                fsCtx.fillRect(0, 0, fishSoulCanvas.width, fishSoulCanvas.height);
                
                // Update vessels
                vessels.forEach(vessel => {
                    vessel.rotation += 0.002;
                    vessel.glowIntensity = 0.5 + Math.sin(Date.now() * 0.001) * 0.3;
                });
                
                // Draw vessels
                vessels.forEach(drawVessel);
                
                // Update and draw fish
                fish.forEach(f => {
                    f.angle += f.speed;
                    f.tailPhase += 0.1;
                    drawFish(f);
                });
                
                fishSoulAnimation = requestAnimationFrame(animateFishSoul);
            }
            
            animateFishSoul();
        }
        
        // Visualization 2: Multiplication and Unity
        const multiplicationCanvas = document.getElementById('multiplicationCanvas');
        const mCtx = multiplicationCanvas.getContext('2d');
        let multiplicationAnimation;
        let isUnified = true;
        let particles = [];
        
        function initMultiplicationViz() {
            multiplicationCanvas.width = multiplicationCanvas.parentElement.offsetWidth;
            multiplicationCanvas.height = 500;
            
            // Create central fish that can split
            const centerX = multiplicationCanvas.width / 2;
            const centerY = multiplicationCanvas.height / 2;
            
            function createParticles() {
                particles = [];
                if (isUnified) {
                    // Single large fish
                    particles.push({
                        x: centerX,
                        y: centerY,
                        targetX: centerX,
                        targetY: centerY,
                        size: 60,
                        rotation: 0,
                        color: '#D4AF37',
                        alpha: 1
                    });
                } else {
                    // Multiple smaller fish
                    const count = 12;
                    for (let i = 0; i < count; i++) {
                        const angle = (i * Math.PI * 2) / count;
                        const radius = 150;
                        particles.push({
                            x: centerX,
                            y: centerY,
                            targetX: centerX + Math.cos(angle) * radius,
                            targetY: centerY + Math.sin(angle) * radius,
                            size: 20,
                            rotation: angle,
                            color: `hsl(${45 + (i * 15)}, 70%, 50%)`,
                            alpha: 0.8,
                            orbitAngle: angle,
                            orbitSpeed: 0.01 + Math.random() * 0.01
                        });
                    }
                }
            }
            
            createParticles();
            
            function drawMandorla(x, y, radius) {
                mCtx.save();
                mCtx.translate(x, y);
                
                // Create intersecting circles effect
                mCtx.globalCompositeOperation = 'screen';
                
                const gradient1 = mCtx.createRadialGradient(-radius/3, 0, 0, -radius/3, 0, radius);
                gradient1.addColorStop(0, 'rgba(212, 175, 55, 0.3)');
                gradient1.addColorStop(1, 'transparent');
                
                const gradient2 = mCtx.createRadialGradient(radius/3, 0, 0, radius/3, 0, radius);
                gradient2.addColorStop(0, 'rgba(212, 175, 55, 0.3)');
                gradient2.addColorStop(1, 'transparent');
                
                mCtx.fillStyle = gradient1;
                mCtx.beginPath();
                mCtx.arc(-radius/3, 0, radius, 0, Math.PI * 2);
                mCtx.fill();
                
                mCtx.fillStyle = gradient2;
                mCtx.beginPath();
                mCtx.arc(radius/3, 0, radius, 0, Math.PI * 2);
                mCtx.fill();
                
                mCtx.globalCompositeOperation = 'source-over';
                mCtx.restore();
            }
            
            function drawParticleFish(p) {
                mCtx.save();
                mCtx.translate(p.x, p.y);
                mCtx.rotate(p.rotation);
                mCtx.globalAlpha = p.alpha;
                
                // Fish shape
                mCtx.fillStyle = p.color;
                mCtx.beginPath();
                mCtx.ellipse(0, 0, p.size * 0.4, p.size, 0, 0, Math.PI * 2);
                mCtx.fill();
                
                // Tail
                mCtx.beginPath();
                mCtx.moveTo(0, p.size);
                mCtx.quadraticCurveTo(-p.size * 0.5, p.size * 1.2, -p.size * 0.3, p.size * 1.5);
                mCtx.quadraticCurveTo(0, p.size * 1.2, p.size * 0.3, p.size * 1.5);
                mCtx.quadraticCurveTo(p.size * 0.5, p.size * 1.2, 0, p.size);
                mCtx.fill();
                
                // Eye
                mCtx.fillStyle = '#fff';
                mCtx.beginPath();
                mCtx.arc(-p.size * 0.2, -p.size * 0.3, p.size * 0.05, 0, Math.PI * 2);
                mCtx.fill();
                
                mCtx.restore();
            }
            
            window.toggleMultiplication = function() {
                isUnified = !isUnified;
                createParticles();
            };
            
            window.resetMultiplication = function() {
                isUnified = true;
                createParticles();
            };
            
            function animateMultiplication() {
                mCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                mCtx.fillRect(0, 0, multiplicationCanvas.width, multiplicationCanvas.height);
                
                // Draw mandorla background
                drawMandorla(centerX, centerY, 200);
                
                // Update particles
                particles.forEach(p => {
                    // Smooth transition
                    p.x += (p.targetX - p.x) * 0.1;
                    p.y += (p.targetY - p.y) * 0.1;
                    
                    if (!isUnified && p.orbitAngle !== undefined) {
                        p.orbitAngle += p.orbitSpeed;
                        p.targetX = centerX + Math.cos(p.orbitAngle) * 150;
                        p.targetY = centerY + Math.sin(p.orbitAngle) * 150;
                        p.rotation = p.orbitAngle + Math.PI / 2;
                    }
                    
                    drawParticleFish(p);
                });
                
                // Draw unity symbol
                if (isUnified) {
                    mCtx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                    mCtx.lineWidth = 2;
                    mCtx.beginPath();
                    mCtx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                    mCtx.stroke();
                }
                
                multiplicationAnimation = requestAnimationFrame(animateMultiplication);
            }
            
            animateMultiplication();
        }
        
        // Visualization 3: The Fish King (Rex Marinus)
        const fishKingCanvas = document.getElementById('fishKingCanvas');
        const fkCtx = fishKingCanvas.getContext('2d');
        let fishKingAnimation;
        
        function initFishKingViz() {
            fishKingCanvas.width = fishKingCanvas.parentElement.offsetWidth;
            fishKingCanvas.height = 500;
            
            const waves = [];
            const bubbles = [];
            let crownGlow = 0;
            
            // Create wave layers
            for (let i = 0; i < 5; i++) {
                waves.push({
                    y: fishKingCanvas.height * 0.7 + i * 20,
                    amplitude: 10 + i * 5,
                    frequency: 0.01 - i * 0.002,
                    phase: i * 0.5,
                    opacity: 0.3 - i * 0.05
                });
            }
            
            // Create bubbles
            for (let i = 0; i < 20; i++) {
                bubbles.push({
                    x: Math.random() * fishKingCanvas.width,
                    y: fishKingCanvas.height + Math.random() * 100,
                    radius: 2 + Math.random() * 6,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: Math.random() * Math.PI * 2
                });
            }
            
            function drawWaves() {
                waves.forEach(wave => {
                    fkCtx.beginPath();
                    fkCtx.moveTo(0, wave.y);
                    
                    for (let x = 0; x <= fishKingCanvas.width; x += 5) {
                        const y = wave.y + Math.sin(x * wave.frequency + wave.phase) * wave.amplitude;
                        fkCtx.lineTo(x, y);
                    }
                    
                    fkCtx.lineTo(fishKingCanvas.width, fishKingCanvas.height);
                    fkCtx.lineTo(0, fishKingCanvas.height);
                    fkCtx.closePath();
                    
                    fkCtx.fillStyle = `rgba(0, 50, 100, ${wave.opacity})`;
                    fkCtx.fill();
                    
                    wave.phase += 0.02;
                });
            }
            
            function drawBubbles() {
                bubbles.forEach(bubble => {
                    fkCtx.save();
                    fkCtx.globalAlpha = 0.6;
                    
                    const gradient = fkCtx.createRadialGradient(
                        bubble.x - bubble.radius * 0.3,
                        bubble.y - bubble.radius * 0.3,
                        0,
                        bubble.x,
                        bubble.y,
                        bubble.radius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(200, 220, 255, 0.3)');
                    gradient.addColorStop(1, 'transparent');
                    
                    fkCtx.fillStyle = gradient;
                    fkCtx.beginPath();
                    fkCtx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    fkCtx.fill();
                    
                    fkCtx.restore();
                    
                    // Update bubble
                    bubble.y -= bubble.speed;
                    bubble.x += Math.sin(bubble.wobble) * 0.5;
                    bubble.wobble += 0.05;
                    
                    if (bubble.y < -bubble.radius) {
                        bubble.y = fishKingCanvas.height + bubble.radius;
                        bubble.x = Math.random() * fishKingCanvas.width;
                    }
                });
            }
            
            function drawFishKing() {
                const centerX = fishKingCanvas.width / 2;
                const centerY = fishKingCanvas.height / 2.5;
                const time = Date.now() * 0.001;
                
                // Royal aura
                const auraGradient = fkCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150);
                auraGradient.addColorStop(0, 'rgba(212, 175, 55, 0.3)');
                auraGradient.addColorStop(0.5, 'rgba(212, 175, 55, 0.1)');
                auraGradient.addColorStop(1, 'transparent');
                
                fkCtx.fillStyle = auraGradient;
                fkCtx.fillRect(centerX - 200, centerY - 200, 400, 400);
                
                fkCtx.save();
                fkCtx.translate(centerX, centerY);
                
                // Majestic fish body
                const scale = 1 + Math.sin(time * 0.5) * 0.05;
                fkCtx.scale(scale, scale);
                
                // Body gradient
                const bodyGradient = fkCtx.createLinearGradient(-80, -40, 80, 40);
                bodyGradient.addColorStop(0, '#D4AF37');
                bodyGradient.addColorStop(0.5, '#F4E19C');
                bodyGradient.addColorStop(1, '#B8960F');
                
                fkCtx.fillStyle = bodyGradient;
                fkCtx.beginPath();
                fkCtx.ellipse(0, 0, 80, 40, 0, 0, Math.PI * 2);
                fkCtx.fill();
                
                // Scales pattern
                fkCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                fkCtx.lineWidth = 1;
                for (let i = -60; i < 60; i += 15) {
                    for (let j = -20; j < 20; j += 10) {
                        fkCtx.beginPath();
                        fkCtx.arc(i, j, 8, 0, Math.PI, true);
                        fkCtx.stroke();
                    }
                }
                
                // Royal tail
                fkCtx.fillStyle = bodyGradient;
                fkCtx.beginPath();
                fkCtx.moveTo(60, 0);
                fkCtx.quadraticCurveTo(100, -30, 120, -40);
                fkCtx.quadraticCurveTo(110, -10, 100, 0);
                fkCtx.quadraticCurveTo(110, 10, 120, 40);
                fkCtx.quadraticCurveTo(100, 30, 60, 0);
                fkCtx.fill();
                
                // Crown
                crownGlow = 0.7 + Math.sin(time * 2) * 0.3;
                fkCtx.shadowBlur = 20;
                fkCtx.shadowColor = `rgba(212, 175, 55, ${crownGlow})`;
                
                fkCtx.fillStyle = '#D4AF37';
                fkCtx.beginPath();
                // Crown base
                fkCtx.rect(-30, -50, 60, 10);
                fkCtx.fill();
                
                // Crown peaks
                const peaks = [
                    {x: -25, h: 25},
                    {x: -15, h: 20},
                    {x: 0, h: 30},
                    {x: 15, h: 20},
                    {x: 25, h: 25}
                ];
                
                peaks.forEach(peak => {
                    fkCtx.beginPath();
                    fkCtx.moveTo(peak.x - 5, -50);
                    fkCtx.lineTo(peak.x, -50 - peak.h);
                    fkCtx.lineTo(peak.x + 5, -50);
                    fkCtx.fill();
                    
                    // Jewels
                    fkCtx.fillStyle = '#FF6B6B';
                    fkCtx.beginPath();
                    fkCtx.arc(peak.x, -50 - peak.h + 5, 3, 0, Math.PI * 2);
                    fkCtx.fill();
                    fkCtx.fillStyle = '#D4AF37';
                });
                
                fkCtx.shadowBlur = 0;
                
                // Eye
                fkCtx.fillStyle = '#fff';
                fkCtx.beginPath();
                fkCtx.arc(-50, -10, 8, 0, Math.PI * 2);
                fkCtx.fill();
                
                fkCtx.fillStyle = '#000';
                fkCtx.beginPath();
                fkCtx.arc(-50, -10, 4, 0, Math.PI * 2);
                fkCtx.fill();
                
                fkCtx.restore();
            }
            
            function animateFishKing() {
                fkCtx.fillStyle = 'rgba(0, 10, 30, 0.1)';
                fkCtx.fillRect(0, 0, fishKingCanvas.width, fishKingCanvas.height);
                
                drawWaves();
                drawBubbles();
                drawFishKing();
                
                fishKingAnimation = requestAnimationFrame(animateFishKing);
            }
            
            animateFishKing();
        }
        
        // Visualization 4: Alchemical Transformation Stages
        const transformationCanvas = document.getElementById('transformationCanvas');
        const tCtx = transformationCanvas.getContext('2d');
        let transformationAnimation;
        let currentStage = 'catching';
        let stageProgress = 0;
        let isPlaying = false;
        
        function initTransformationViz() {
            transformationCanvas.width = transformationCanvas.parentElement.offsetWidth;
            transformationCanvas.height = 500;
            
            const stages = {
                catching: {
                    color: '#4A90E2',
                    symbol: '🎣',
                    description: 'Catching - Drawing from the Unconscious'
                },
                killing: {
                    color: '#E74C3C',
                    symbol: '⚔️',
                    description: 'Killing - Separating from Identification'
                },
                cooking: {
                    color: '#F39C12',
                    symbol: '🔥',
                    description: 'Cooking - Transforming Through Heat'
                },
                eating: {
                    color: '#27AE60',
                    symbol: '✨',
                    description: 'Eating - Integration into Consciousness'
                }
            };
            
            const stageOrder = ['catching', 'killing', 'cooking', 'eating'];
            
            window.showStage = function(stage) {
                currentStage = stage;
                stageProgress = 0;
                isPlaying = false;
            };
            
            window.playSequence = function() {
                currentStage = 'catching';
                stageProgress = 0;
                isPlaying = true;
            };
            
            function drawStage() {
                const stage = stages[currentStage];
                const centerX = transformationCanvas.width / 2;
                const centerY = transformationCanvas.height / 2;
                
                // Background effect
                const bgGradient = tCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 250);
                bgGradient.addColorStop(0, stage.color + '33');
                bgGradient.addColorStop(1, 'transparent');
                tCtx.fillStyle = bgGradient;
                tCtx.fillRect(0, 0, transformationCanvas.width, transformationCanvas.height);
                
                // Stage title
                tCtx.font = '24px Georgia';
                tCtx.fillStyle = stage.color;
                tCtx.textAlign = 'center';
                tCtx.fillText(stage.description, centerX, 50);
                
                // Draw stage-specific visualization
                switch(currentStage) {
                    case 'catching':
                        drawCatchingStage(centerX, centerY);
                        break;
                    case 'killing':
                        drawKillingStage(centerX, centerY);
                        break;
                    case 'cooking':
                        drawCookingStage(centerX, centerY);
                        break;
                    case 'eating':
                        drawEatingStage(centerX, centerY);
                        break;
                }
                
                // Progress indicator
                if (isPlaying) {
                    const totalStages = stageOrder.length;
                    const currentIndex = stageOrder.indexOf(currentStage);
                    const overallProgress = (currentIndex + stageProgress) / totalStages;
                    
                    tCtx.strokeStyle = '#D4AF37';
                    tCtx.lineWidth = 3;
                    tCtx.beginPath();
                    tCtx.moveTo(50, transformationCanvas.height - 30);
                    tCtx.lineTo(50 + (transformationCanvas.width - 100) * overallProgress, transformationCanvas.height - 30);
                    tCtx.stroke();
                }
            }
            
            function drawCatchingStage(x, y) {
                // Water surface
                tCtx.strokeStyle = '#4A90E2';
                tCtx.lineWidth = 2;
                tCtx.beginPath();
                for (let i = 0; i < transformationCanvas.width; i += 20) {
                    const wave = Math.sin((i + stageProgress * 10) * 0.05) * 10;
                    tCtx.lineTo(i, y + wave);
                }
                tCtx.stroke();
                
                // Fishing line
                const hookY = y + Math.sin(stageProgress * 0.1) * 50 + 50;
                tCtx.beginPath();
                tCtx.moveTo(x, 100);
                tCtx.quadraticCurveTo(x + 50, y - 50, x, hookY);
                tCtx.stroke();
                
                // Hook
                tCtx.beginPath();
                tCtx.arc(x, hookY, 10, 0, Math.PI);
                tCtx.stroke();
                
                // Fish approaching
                const fishX = x - 100 + stageProgress * 2;
                const fishY = hookY + Math.sin(stageProgress * 0.2) * 20;
                
                tCtx.fillStyle = '#D4AF37';
                tCtx.beginPath();
                tCtx.ellipse(fishX, fishY, 20, 10, 0, 0, Math.PI * 2);
                tCtx.fill();
            }
            
            function drawKillingStage(x, y) {
                // Sword
                tCtx.save();
                tCtx.translate(x, y);
                tCtx.rotate(-Math.PI / 4 + Math.sin(stageProgress * 0.1) * 0.1);
                
                // Blade
                const bladeGradient = tCtx.createLinearGradient(-50, -100, 50, 100);
                bladeGradient.addColorStop(0, '#C0C0C0');
                bladeGradient.addColorStop(0.5, '#FFFFFF');
                bladeGradient.addColorStop(1, '#C0C0C0');
                
                tCtx.fillStyle = bladeGradient;
                tCtx.beginPath();
                tCtx.moveTo(0, -100);
                tCtx.lineTo(-10, 50);
                tCtx.lineTo(0, 60);
                tCtx.lineTo(10, 50);
                tCtx.closePath();
                tCtx.fill();
                
                // Hilt
                tCtx.fillStyle = '#8B4513';
                tCtx.fillRect(-20, 60, 40, 15);
                tCtx.fillRect(-5, 75, 10, 30);
                
                tCtx.restore();
                
                // Separating elements
                const separation = stageProgress * 2;
                tCtx.fillStyle = 'rgba(212, 175, 55, 0.5)';
                tCtx.beginPath();
                tCtx.arc(x - separation, y, 30, 0, Math.PI * 2);
                tCtx.fill();
                
                tCtx.fillStyle = 'rgba(74, 144, 226, 0.5)';
                tCtx.beginPath();
                tCtx.arc(x + separation, y, 30, 0, Math.PI * 2);
                tCtx.fill();
            }
            
            function drawCookingStage(x, y) {
                // Alchemical vessel
                tCtx.strokeStyle = '#8B4513';
                tCtx.lineWidth = 3;
                tCtx.beginPath();
                tCtx.arc(x, y, 80, 0, Math.PI);
                tCtx.lineTo(x - 80, y + 40);
                tCtx.lineTo(x + 80, y + 40);
                tCtx.closePath();
                tCtx.stroke();
                
                // Fire
                const flames = 5;
                for (let i = 0; i < flames; i++) {
                    const flameX = x + (i - 2) * 30;
                    const flameHeight = 30 + Math.sin(stageProgress * 0.2 + i) * 10;
                    
                    const flameGradient = tCtx.createLinearGradient(
                        flameX, y + 60,
                        flameX, y + 60 + flameHeight
                    );
                    flameGradient.addColorStop(0, '#FF6B6B');
                    flameGradient.addColorStop(0.5, '#FFA500');
                    flameGradient.addColorStop(1, '#FFD700');
                    
                    tCtx.fillStyle = flameGradient;
                    tCtx.beginPath();
                    tCtx.moveTo(flameX - 10, y + 60);
                    tCtx.quadraticCurveTo(flameX, y + 60 + flameHeight, flameX + 10, y + 60);
                    tCtx.fill();
                }
                
                // Bubbling contents
                tCtx.fillStyle = 'rgba(212, 175, 55, 0.7)';
                for (let i = 0; i < 5; i++) {
                    const bubbleX = x + (Math.random() - 0.5) * 120;
                    const bubbleY = y - Math.random() * 40;
                    const bubbleSize = 5 + Math.random() * 10;
                    
                    tCtx.beginPath();
                    tCtx.arc(bubbleX, bubbleY - stageProgress % 50, bubbleSize, 0, Math.PI * 2);
                    tCtx.fill();
                }
            }
            
            function drawEatingStage(x, y) {
                // Radiant center
                const pulseSize = 50 + Math.sin(stageProgress * 0.1) * 20;
                const radialGradient = tCtx.createRadialGradient(x, y, 0, x, y, pulseSize * 2);
                radialGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                radialGradient.addColorStop(0.3, 'rgba(212, 175, 55, 0.6)');
                radialGradient.addColorStop(0.6, 'rgba(212, 175, 55, 0.3)');
                radialGradient.addColorStop(1, 'transparent');
                
                tCtx.fillStyle = radialGradient;
                tCtx.fillRect(x - 200, y - 200, 400, 400);
                
                // Integration spirals
                tCtx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                tCtx.lineWidth = 2;
                
                for (let i = 0; i < 3; i++) {
                    tCtx.beginPath();
                    const startAngle = (i * Math.PI * 2) / 3 + stageProgress * 0.05;
                    for (let t = 0; t < Math.PI * 4; t += 0.1) {
                        const r = t * 10;
                        const px = x + Math.cos(t + startAngle) * r;
                        const py = y + Math.sin(t + startAngle) * r;
                        tCtx.lineTo(px, py);
                    }
                    tCtx.stroke();
                }
                
                // Central unified symbol
                tCtx.fillStyle = '#D4AF37';
                tCtx.font = '48px Georgia';
                tCtx.textAlign = 'center';
                tCtx.fillText('☉', x, y + 15);
            }
            
            function animateTransformation() {
                tCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                tCtx.fillRect(0, 0, transformationCanvas.width, transformationCanvas.height);
                
                drawStage();
                
                stageProgress += 1;
                
                // Auto-advance stages when playing sequence
                if (isPlaying && stageProgress > 100) {
                    const currentIndex = stageOrder.indexOf(currentStage);
                    if (currentIndex < stageOrder.length - 1) {
                        currentStage = stageOrder[currentIndex + 1];
                        stageProgress = 0;
                    } else {
                        isPlaying = false;
                    }
                }
                
                transformationAnimation = requestAnimationFrame(animateTransformation);
            }
            
            animateTransformation();
        }
        
        // Initialize all visualizations
        initFishSoulViz();
        initMultiplicationViz();
        initFishKingViz();
        initTransformationViz();
        
        // Handle window resize
        window.addEventListener('resize', function() {
            // Cancel existing animations
            cancelAnimationFrame(fishSoulAnimation);
            cancelAnimationFrame(multiplicationAnimation);
            cancelAnimationFrame(fishKingAnimation);
            cancelAnimationFrame(transformationAnimation);
            
            // Reinitialize with new dimensions
            initFishSoulViz();
            initMultiplicationViz();
            initFishKingViz();
            initTransformationViz();
        });
    });
    </script>
</body>
</html>