<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: The Shadow - Aion Visualization</title>
    <link rel="stylesheet" href="../../assets/css/main.css">
    <style>
        .chapter-hero {
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chapter-hero-content {
            text-align: center;
            z-index: 10;
            opacity: 0;
            animation: fadeInUp 1.2s ease-out 0.5s forwards;
        }
        
        .chapter-content {
            padding: var(--space-16) 0;
        }
        
        .content-block {
            max-width: 800px;
            margin: 0 auto var(--space-16);
            opacity: 0;
            transform: translateY(40px);
        }
        
        .content-block.visible {
            animation: fadeInUp 0.8s ease-out forwards;
        }
        
        .visualization-container {
            height: 60vh;
            margin: var(--space-8) 0;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: var(--surface-glass);
            border: 1px solid var(--border-subtle);
        }
        
        .quote {
            font-size: var(--text-2xl);
            font-weight: 300;
            font-style: italic;
            color: var(--text-secondary);
            text-align: center;
            margin: var(--space-8) auto;
            max-width: 800px;
            opacity: 0.8;
        }
        
        .author {
            display: block;
            font-size: var(--text-base);
            font-style: normal;
            margin-top: var(--space-2);
            color: var(--text-tertiary);
        }
        
        .shadow-aspects {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-4);
            margin-top: var(--space-6);
        }
        
        .shadow-card {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: var(--space-6);
            border-radius: 8px;
            transition: all var(--transition-base);
        }
        
        .shadow-card:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.1);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-container">
            <a href="../../index.html" class="nav-link">Home</a>
            <a href="../index.html" class="nav-link">Chapters</a>
            <a href="timeline.html" class="nav-link">Timeline</a>
            <a href="symbols.html" class="nav-link">Symbols</a>
            <a href="../../src/about.html" class="nav-link">About</a>
        </div>
    </nav>
    
    <!-- Chapter Hero -->
    <section class="chapter-hero">
        <canvas id="shadow-visualization" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
        <div class="chapter-hero-content">
            <span class="chapter-number">Chapter 02</span>
            <h1 style="font-size: var(--text-7xl); font-weight: 200; margin: var(--space-4) 0;">
                The Shadow
            </h1>
            <p style="font-size: var(--text-xl); color: var(--text-secondary);">
                The dark brother within
            </p>
        </div>
    </section>
    
    <!-- Content -->
    <section class="chapter-content">
        <div class="container">
            <div class="content-block">
                <p class="quote">
                    "Everyone carries a shadow, and the less it is embodied in the individual's conscious life, the blacker and denser it is."
                    <span class="author">— C.G. Jung</span>
                </p>
            </div>
            
            <div class="content-block">
                <h2 style="font-size: var(--text-3xl); margin-bottom: var(--space-4);">
                    Understanding the Shadow
                </h2>
                <p>
                    The shadow represents the parts of ourselves that we deny or repress. It contains 
                    not only our unacceptable impulses and weaknesses but also undeveloped aspects 
                    of the personality that have been pushed into the unconscious.
                </p>
                <p style="margin-top: var(--space-3);">
                    In Aion, Jung explores how the shadow manifests both personally and collectively, 
                    particularly through the figure of the Antichrist as the shadow of the Christian ideal.
                </p>
            </div>
            
            <div class="content-block">
                <h3 style="font-size: var(--text-2xl); margin-bottom: var(--space-4);">
                    Shadow Dynamics
                </h3>
                <div class="visualization-container" id="shadow-integration-container">
                    <div class="viz-loading" style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary);">
                        <div>Loading Shadow Integration Demo...</div>
                    </div>
                </div>
                <p style="margin-top: var(--space-4);">
                    The shadow operates through projection—we see in others what we cannot accept 
                    in ourselves. Recognition and integration of the shadow is essential for 
                    psychological wholeness.
                </p>
            </div>
            
            <div class="content-block">
                <h3 style="font-size: var(--text-2xl); margin-bottom: var(--space-4);">
                    Aspects of the Shadow
                </h3>
                <div class="shadow-aspects">
                    <div class="shadow-card">
                        <h4 style="margin-bottom: var(--space-2);">Personal Shadow</h4>
                        <p style="font-size: var(--text-base);">
                            Individual repressed contents unique to one's life history
                        </p>
                    </div>
                    <div class="shadow-card">
                        <h4 style="margin-bottom: var(--space-2);">Collective Shadow</h4>
                        <p style="font-size: var(--text-base);">
                            Cultural and societal rejected elements shared by groups
                        </p>
                    </div>
                    <div class="shadow-card">
                        <h4 style="margin-bottom: var(--space-2);">Positive Shadow</h4>
                        <p style="font-size: var(--text-base);">
                            Hidden potentials and undeveloped talents
                        </p>
                    </div>
                    <div class="shadow-card">
                        <h4 style="margin-bottom: var(--space-2);">Archetypal Shadow</h4>
                        <p style="font-size: var(--text-base);">
                            Universal dark aspects of human nature
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- Navigation -->
            <div style="display: flex; justify-content: space-between; margin-top: var(--space-16);">
                <a href="chapter1.html" class="button">← Chapter 1: The Ego</a>
                <a href="chapter3.html" class="button">Chapter 3: The Syzygy →</a>
            </div>
        </div>
    </section>
    
    <!-- Shadow Visualization Shaders -->
    <script>
        // Hero Shadow Fluid Simulation
        (function() {
            const canvas = document.getElementById('shadow-visualization');
            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Dark fluid shader
            const fluidShader = {
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    mouse: { value: new THREE.Vector2(0.5, 0.5) }
                },
                vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec2 resolution;
                    uniform vec2 mouse;
                    
                    // Simplex noise function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                            
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    void main() {
                        vec2 uv = gl_FragCoord.xy / resolution.xy;
                        vec2 pos = uv * 2.0 - 1.0;
                        pos.x *= resolution.x / resolution.y;
                        
                        // Create flowing dark matter
                        float n1 = snoise(vec3(pos * 3.0, time * 0.2));
                        float n2 = snoise(vec3(pos * 5.0 - vec2(time * 0.1, 0.0), time * 0.3));
                        float n3 = snoise(vec3(pos * 8.0 + vec2(0.0, time * 0.15), time * 0.1));
                        
                        // Combine noise layers
                        float shadow = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
                        shadow = shadow * 0.5 + 0.5;
                        
                        // Mouse interaction - shadow recoils from light
                        float mouseDist = distance(uv, mouse);
                        shadow *= 1.0 + smoothstep(0.3, 0.0, mouseDist) * -0.5;
                        
                        // Create depth and darkness
                        vec3 color = vec3(0.0);
                        color += vec3(0.05, 0.02, 0.08) * shadow;
                        color *= 1.0 - smoothstep(0.0, 1.0, length(pos) * 0.5);
                        
                        // Add subtle purple hints in the darkness
                        color += vec3(0.1, 0.05, 0.15) * (1.0 - shadow) * 0.3;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            };
            
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial(fluidShader);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            // Mouse tracking
            let mouseX = 0.5, mouseY = 0.5;
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX / window.innerWidth;
                mouseY = 1.0 - (e.clientY / window.innerHeight);
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                material.uniforms.time.value += 0.01;
                material.uniforms.mouse.value.x += (mouseX - material.uniforms.mouse.value.x) * 0.05;
                material.uniforms.mouse.value.y += (mouseY - material.uniforms.mouse.value.y) * 0.05;
                
                renderer.render(scene, camera);
            }
            
            // Handle resize
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                material.uniforms.resolution.value.set(width, height);
            });
            
            animate();
        })();
        
        // Shadow Dynamics Visualization
        (function() {
            const canvas = document.getElementById('shadow-dynamics');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                50, 
                canvas.parentElement.offsetWidth / canvas.parentElement.offsetHeight, 
                0.1, 
                1000
            );
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            
            renderer.setSize(canvas.parentElement.offsetWidth, canvas.parentElement.offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            camera.position.set(0, 0, 5);
            
            // Create conscious sphere (light)
            const consciousGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const consciousMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const consciousSphere = new THREE.Mesh(consciousGeometry, consciousMaterial);
            consciousSphere.position.x = -1;
            scene.add(consciousSphere);
            
            // Create shadow sphere (dark)
            const shadowGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.8
            });
            const shadowSphere = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadowSphere.position.x = 1;
            scene.add(shadowSphere);
            
            // Create projection rays
            const projectionGroup = new THREE.Group();
            const rayCount = 20;
            
            for (let i = 0; i < rayCount; i++) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({
                    color: 0x6B46C1,
                    transparent: true,
                    opacity: 0
                });
                
                const line = new THREE.Line(geometry, material);
                projectionGroup.add(line);
            }
            
            scene.add(projectionGroup);
            
            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.01;
                
                // Oscillate spheres
                consciousSphere.position.y = Math.sin(time) * 0.2;
                shadowSphere.position.y = -Math.sin(time) * 0.2;
                
                // Update projection rays
                projectionGroup.children.forEach((line, i) => {
                    const positions = line.geometry.attributes.position.array;
                    const angle = (i / rayCount) * Math.PI * 2 + time;
                    const radius = 0.3;
                    
                    // Start from conscious sphere
                    positions[0] = consciousSphere.position.x + Math.cos(angle) * radius;
                    positions[1] = consciousSphere.position.y + Math.sin(angle) * radius;
                    positions[2] = 0;
                    
                    // End at shadow sphere
                    positions[3] = shadowSphere.position.x + Math.cos(angle + Math.PI) * radius;
                    positions[4] = shadowSphere.position.y + Math.sin(angle + Math.PI) * radius;
                    positions[5] = 0;
                    
                    line.geometry.attributes.position.needsUpdate = true;
                    
                    // Fade in and out
                    line.material.opacity = (Math.sin(time * 2 + i * 0.5) + 1) * 0.2;
                });
                
                renderer.render(scene, camera);
            }
            
            // Handle resize
            window.addEventListener('resize', () => {
                const width = canvas.parentElement.offsetWidth;
                const height = canvas.parentElement.offsetHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
            
            animate();
        })();
        
        // Scroll animations
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -10% 0px'
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, observerOptions);
        
        document.querySelectorAll('.content-block').forEach(block => {
            observer.observe(block);
        });
        
        // Load Shadow Integration Visualization
        async function loadShadowIntegration() {
            const container = document.getElementById('shadow-integration-container');
            const loadingDiv = container.querySelector('.viz-loading');
            
            try {
                // Wait for Matter.js to load
                if (!window.Matter) {
                    await new Promise((resolve, reject) => {
                        const checkMatter = () => {
                            if (window.Matter) {
                                resolve();
                            } else {
                                setTimeout(checkMatter, 100);
                            }
                        };
                        checkMatter();
                        
                        // Timeout after 5 seconds
                        setTimeout(() => reject(new Error('Matter.js failed to load')), 5000);
                    });
                }
                
                // Clear loading indicator
                if (loadingDiv) loadingDiv.remove();
                
                // Create simplified shadow integration visualization
                createSimpleShadowVisualization(container);
                
                console.log('Shadow Integration visualization loaded successfully');
            } catch (error) {
                console.error('Failed to load Shadow Integration:', error);
                if (loadingDiv) {
                    loadingDiv.innerHTML = '<div style="color: #ff6b6b;">Failed to load visualization. <a href="../../src/visualizations/shadow/shadow-demo.html" style="color: #ffd700;">View standalone demo</a></div>';
                }
            }
        }
        
        function createSimpleShadowVisualization(container) {
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            canvas.style.display = 'block';
            container.appendChild(canvas);
            
            // Initialize Matter.js
            const engine = Matter.Engine.create();
            engine.world.gravity.y = 0;
            
            const render = Matter.Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: canvas.width,
                    height: canvas.height,
                    wireframes: false,
                    background: 'transparent',
                    showVelocity: false,
                    showAngleIndicator: false,
                    showDebug: false
                }
            });
            
            // Create boundaries
            const walls = [
                Matter.Bodies.rectangle(canvas.width/2, -25, canvas.width, 50, { isStatic: true, render: { visible: false } }),
                Matter.Bodies.rectangle(canvas.width/2, canvas.height + 25, canvas.width, 50, { isStatic: true, render: { visible: false } }),
                Matter.Bodies.rectangle(-25, canvas.height/2, 50, canvas.height, { isStatic: true, render: { visible: false } }),
                Matter.Bodies.rectangle(canvas.width + 25, canvas.height/2, 50, canvas.height, { isStatic: true, render: { visible: false } })
            ];
            Matter.World.add(engine.world, walls);
            
            // Create particles
            const particles = [];
            const divisionY = canvas.height * 0.5;
            
            // Shadow particles (top - conscious realm)
            for (let i = 0; i < 15; i++) {
                const particle = Matter.Bodies.circle(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (divisionY - 100) + 50,
                    8 + Math.random() * 6,
                    {
                        render: {
                            fillStyle: '#2D1B69',
                            strokeStyle: '#6B46C1',
                            lineWidth: 1
                        },
                        restitution: 0.8,
                        friction: 0.001,
                        particleType: 'shadow'
                    }
                );
                particles.push(particle);
            }
            
            // Light particles (bottom - unconscious realm)
            for (let i = 0; i < 10; i++) {
                const particle = Matter.Bodies.circle(
                    Math.random() * (canvas.width - 100) + 50,
                    divisionY + Math.random() * (canvas.height - divisionY - 100) + 50,
                    6 + Math.random() * 4,
                    {
                        render: {
                            fillStyle: '#FDE047',
                            strokeStyle: '#EAB308',
                            lineWidth: 1
                        },
                        restitution: 0.8,
                        friction: 0.001,
                        particleType: 'light'
                    }
                );
                particles.push(particle);
            }
            
            Matter.World.add(engine.world, particles);
            
            // Add mouse control
            const mouse = Matter.Mouse.create(canvas);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: { visible: false }
                }
            });
            Matter.World.add(engine.world, mouseConstraint);
            
            // Add gentle forces to keep particles moving
            setInterval(() => {
                particles.forEach(particle => {
                    const force = {
                        x: (Math.random() - 0.5) * 0.0002,
                        y: (Math.random() - 0.5) * 0.0002
                    };
                    Matter.Body.applyForce(particle, particle.position, force);
                });
            }, 1000);
            
            // Custom rendering for realm division
            Matter.Events.on(render, 'afterRender', () => {
                const ctx = canvas.getContext('2d');
                
                // Draw realm division line
                ctx.strokeStyle = 'rgba(156, 163, 175, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(0, divisionY);
                ctx.lineTo(canvas.width, divisionY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.font = '12px system-ui, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.textAlign = 'left';
                ctx.fillText('CONSCIOUS', 20, 25);
                
                ctx.fillStyle = 'rgba(156, 163, 175, 0.8)';
                ctx.fillText('UNCONSCIOUS', 20, canvas.height - 15);
            });
            
            // Start the simulation
            Matter.Render.run(render);
            const runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);
            
            // Handle resize
            const handleResize = () => {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                render.options.width = canvas.width;
                render.options.height = canvas.height;
            };
            
            window.addEventListener('resize', handleResize);
            
            return {
                destroy: () => {
                    Matter.Render.stop(render);
                    Matter.Runner.stop(runner);
                    Matter.World.clear(engine.world);
                    Matter.Engine.clear(engine);
                    window.removeEventListener('resize', handleResize);
                    if (canvas.parentNode) {
                        canvas.parentNode.removeChild(canvas);
                    }
                }
            };
        }
        
        // Load when page is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadShadowIntegration);
        } else {
            loadShadowIntegration();
        }
    </script>
    <script src="../../assets/js/core/utilities.js"></script>
    <script src="personalization.js"></script>
</body>
</html>